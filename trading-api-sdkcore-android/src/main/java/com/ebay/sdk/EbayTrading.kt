package com.ebay.sdk

import android.net.Uri
import androidx.core.net.toUri
import com.ebay.soap.eBLBaseComponents.AbstractRequestType
import com.ebay.soap.eBLBaseComponents.AbstractResponseType
import com.fasterxml.jackson.annotation.JsonInclude
import com.fasterxml.jackson.databind.DeserializationFeature
import com.fasterxml.jackson.databind.PropertyName
import com.fasterxml.jackson.databind.cfg.MapperConfig
import com.fasterxml.jackson.databind.introspect.Annotated
import com.fasterxml.jackson.databind.introspect.AnnotatedClass
import com.fasterxml.jackson.databind.type.TypeFactory
import com.fasterxml.jackson.dataformat.xml.XmlMapper
import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator
import com.fasterxml.jackson.module.jakarta.xmlbind.JakartaXmlBindAnnotationIntrospector
import jakarta.xml.bind.annotation.XmlElement
import jakarta.xml.bind.annotation.XmlSchema
import jakarta.xml.bind.annotation.XmlType
import kotlinx.coroutines.Deferred
import kotlinx.coroutines.async
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.suspendCancellableCoroutine
import okhttp3.Call
import okhttp3.Callback
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import okhttp3.Response
import java.io.IOException
import java.lang.reflect.Field
import java.lang.reflect.Method

/**
 * Anything hardcoded follows the conventions in the following documentation link.
 * https://developer.ebay.com/devzone/xml/docs/Concepts/MakingACall.html
 */
class EbayTrading(
    val environment: Environment = Environment.PRODUCTION,
    val apiVersion: String,
    val siteId: String,
    val httpClient: OkHttpClient = OkHttpClient()) {

    enum class Environment(val url: Uri) {
        SANDBOX("https://api.sandbox.ebay.com/ws/api.dll".toUri()),
        PRODUCTION("https://api.ebay.com/ws/api.dll".toUri())
    }

    val xmlMapper: XmlMapper = XmlMapper(); init {
        xmlMapper.setAnnotationIntrospector(AddDefaultNamespaceIntrospector(xmlMapper.typeFactory))
        xmlMapper.configure(ToXmlGenerator.Feature.WRITE_XML_DECLARATION, true)
        // eBay seems to return a lot of undocumented elements that are not part of the WSDL.
        // This will prevent parsing errors due to such properties
        xmlMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        // reduces request payloads by not including properties not being set explicitly
        xmlMapper.setDefaultPropertyInclusion(JsonInclude.Include.NON_EMPTY)
    }

    // https://github.com/FasterXML/jackson-dataformat-xml/issues/18#issuecomment-1308125741
    // AddDefaultNamespaceIntrospector
    private class AddDefaultNamespaceIntrospector(typeFactory: TypeFactory) : JakartaXmlBindAnnotationIntrospector(typeFactory) {
        override fun findRootName(ac: AnnotatedClass) : PropertyName {
            return PropertyName(ac.getAnnotation(XmlType::class.java).name,
                getPackageNamespace(ac.annotated))
        }

        private fun getPackageNamespace(c: Class<*>): String? {
            @Suppress("RECEIVER_NULLABILITY_MISMATCH_BASED_ON_JAVA_ANNOTATIONS")
            return c.`package`.getAnnotation(XmlSchema::class.java).namespace
        }

        override fun findNamespace(config: MapperConfig<*>, ann: Annotated): String? {
            val ae = ann.annotated
            val xmlElement = ae.getAnnotation(XmlElement::class.java)
            if (xmlElement?.namespace == "##default") {
                if (ae is Field) {
                    return getPackageNamespace(ae.declaringClass)
                } else if (ae is Method) {
                    return getPackageNamespace(ae.declaringClass)
                }
            }
            return super.findNamespace(config, ann)
        }
    }

    fun call(request: AbstractRequestType, accessToken: String) : AbstractResponseType {
        suspend fun inner() : AbstractResponseType {
            val callName = request::class.java.simpleName.replace("RequestType", "")
            val responseClass = Class.forName("${request::class.java.packageName}.${callName}ResponseType")
            val httpRequest = Request.Builder()
                .url(environment.url.toString())
                .post(xmlMapper.writeValueAsBytes(request)
                    .toRequestBody("text/xml; charset=UTF-8".toMediaType()))
                .header("X-EBAY-API-SITEID", siteId)
                .header("X-EBAY-API-COMPATIBILITY-LEVEL", apiVersion)
                .header("X-EBAY-API-IAF-TOKEN", accessToken)
                .header("X-EBAY-API-CALL-NAME", callName)
                .build()
            // generated by Copilot :)
            suspend fun Call.await(): Response = suspendCancellableCoroutine { cont ->
                enqueue(object : Callback {
                    override fun onFailure(call: Call, e: IOException) {
                        if (cont.isCancelled) return
                        cont.resumeWith(Result.failure(e))
                    }

                    override fun onResponse(call: Call, response: Response) {
                        cont.resumeWith(Result.success(response))
                    }
                })

                cont.invokeOnCancellation {
                    try {
                        cancel()
                    } catch (_: Throwable) {
                    }
                }
            }
            // END generated by Copilot :)
            val call = httpClient.newCall(httpRequest)
            val response = call.await()
            return xmlMapper.readValue(response.body.string(), responseClass) as AbstractResponseType
        }

        return runBlocking {
            val call: Deferred<AbstractResponseType> = async {
                return@async inner()
            }
            return@runBlocking call.await()
        }
    }
}